// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Unreal/Core/Containers/StringFwd.hpp"
#include "Unreal/Core/CoreFwd.hpp"
#include "Unreal/Core/CoreTypes.hpp"
#include "Unreal/Core/HAL/PlatformCrt.hpp"
#include "Unreal/Core/Math/NumericLimits.hpp"
#include "Unreal/Core/Misc/CompressionFlags.hpp"
#include "Unreal/Core/Misc/EnumClassFlags.hpp"

#if PLATFORM_CPU_X86_FAMILY
#include <xmmintrin.h> // _mm_prefetch
#elif PLATFORM_CPU_ARM_FAMILY && defined(_MSC_VER)
#include <intrin.h> // __prefetch
#endif

namespace RC::Unreal
{
  class Error;
  class FDelegateHandle;
  class FOutputDevice;
  class FString;
  class FText;
  /*class GenericApplication;
  class IInstallBundleManager;
  class IPlatformChunkInstall;
  class IPlatformCompression;
  class IPlatformHostCommunication;*/
  struct FCustomChunk;
  struct FDefaultDelegateUserPolicy;
  struct FGenericCrashContext;
  struct FGenericMemoryWarningContext;
  struct FGuid;

  enum class ECustomChunkType : uint8;

  template <typename FuncType>
  class TFunction;

  template <typename FuncType, typename UserPolicy>
  class TDelegate;

  #if UE_BUILD_SHIPPING && !WITH_EDITOR
  #define UE_DEBUG_BREAK() ((void)0)
  #else
  #define UE_DEBUG_BREAK() ((void)(FPlatformMisc::IsDebuggerPresent() && ([] () { UE_DEBUG_BREAK_IMPL(); } (), 1)))
  #endif

  /**
   * Generic implementation for most platforms
   */
  struct FGenericPlatformMisc
  {
    /**
     * Called during appInit() after cmd line setup
     */
    static CORE_API void PlatformPreInit();
    static void PlatformInit() { }
	    
    /**
     * Retrieve a environment variable from the system
     *
     * @param VariableName The name of the variable (ie "Path")
     * @return Value of the variable, or an empty string if not set.
     */
    static CORE_API FString GetEnvironmentVariable(const TCHAR* VariableName);

    /**
     * Sets an environment variable to the local process's environment
     *
     * @param VariableName The name of the variable (ie "Path")
     * @param Value The string to set the variable to.
     */
    static CORE_API void SetEnvironmentVar(const TCHAR* VariableName, const TCHAR* Value);

    /**
     * Returns the maximum length of a path
     */
    FORCEINLINE static int32 GetMaxPathLength()
    {
      return 128;
    }

    /**
     * return the delimiter between paths in the PATH environment variable.
     */
    static CORE_API const TCHAR* GetPathVarDelimiter();
    

    /**
     * Returns a unique string for device identification. Differs from the deprecated GetUniqueDeviceId
     * in that there is no default implementation (which used unreliable Mac address determiniation).
     * This code is expected to use platform-specific methods to identify the device.
     *
     * WARNING: Use of this method in your app may imply technical certification requirments for your platform!
     * For instance, consoles often require cert waivers to be in place before calling APIs that can track a device,
     * so be very careful that you are following your platform's protocols for accessing device IDs. See the platform-
     * specific implementations of this method for details on what APIs are used.
     *
     * If you do not have permission to call this on one or more of your platforms, set GET_DEVICE_ID_UNAVAILABLE=1
     * in your build step to ensure that any calls that may be made to this API will simply return an empty string.
     *
     * @return the unique string generated by this platform for this device, or an empty string if one is not available.
     */
    static CORE_API FString GetDeviceId();

    /** Return true if a debugger is present */
    FORCEINLINE static bool IsDebuggerPresent()
    {
  #if UE_BUILD_SHIPPING
      return false;
  #else
      return true; // unknown platforms return true so that they can crash into a debugger
    #endif
    }

    /**
     * Has the OS execute a command and path pair (such as launch a browser)
     *
     * @param ComandType OS hint as to the type of command
     * @param Command the command to execute
     * @param CommandLine the commands to pass to the executable
     * @return whether the command was successful or not
     */
    static bool OsExecute(const TCHAR* CommandType, const TCHAR* Command, const TCHAR* CommandLine = NULL)
    {
      return false;
    }

    FORCEINLINE static void Prefetch(const void* Ptr)
    {
  #if PLATFORM_CPU_X86_FAMILY
      _mm_prefetch(static_cast<const char*>(Ptr), _MM_HINT_T0);
  #elif PLATFORM_CPU_ARM_FAMILY
  #	if defined(_MSC_VER)
      __prefetch(Ptr);
  #	else
    __asm__ __volatile__("prfm pldl1keep, [%[ptr]]\n" ::[ptr] "r"(Ptr) : );
  #	endif
  #else
  #	error Unknown architecture
  #endif
    }
  
  private:
    struct FStaticData;
  };
}
